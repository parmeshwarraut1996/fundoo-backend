{
  "_from": "multer-s3",
  "_id": "multer-s3@2.9.0",
  "_inBundle": false,
  "_integrity": "sha512-qLF8pCD5HhXLLd954q49B63x3bk6Fe0jqD3eM0FVcGtqhiSVuTrchEDAo0mnO5pc34cMuX/CVCCbPkGTjX2xUA==",
  "_location": "/multer-s3",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "multer-s3",
    "fetchSpec": "latest",
    "name": "multer-s3",
    "raw": "multer-s3",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/multer-s3/-/multer-s3-2.9.0.tgz",
  "_shasum": "a946fd8c01c9726076f11949b84943259f8ca8c3",
  "_spec": "multer-s3",
  "_where": "/home/admin1/fundoo",
  "author": {
    "name": "badunk"
  },
  "bugs": {
    "url": "https://github.com/badunk/multer-s3/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "file-type": "^3.3.0",
    "is-svg": "^2.1.0",
    "run-parallel": "^1.1.6"
  },
  "deprecated": false,
  "description": "Streaming multer storage engine for AWS S3",
  "devDependencies": {
    "aws-sdk": "^2.2.32",
    "concat-stream": "^1.5.1",
    "express": "^4.13.1",
    "form-data": "^1.0.0-rc3",
    "mocha": "^2.2.5",
    "multer": "^1.1.0",
    "on-finished": "^2.3.0",
    "standard": "^5.4.1",
    "xtend": "^4.0.1"
  },
  "homepage": "https://github.com/badunk/multer-s3#readme",
  "keywords": [
    "amazon",
    "aws",
    "multer",
    "s3"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "multer-s3",
  "optionalDependencies": {},
  "readme": "# Multer S3\n\nStreaming multer storage engine for AWS S3.\n\nThis project is mostly an integration piece for existing code samples from Multer's [storage engine documentation](https://github.com/expressjs/multer/blob/master/StorageEngine.md) with [s3fs](https://github.com/RiptideElements/s3fs) as the substitution piece for file system.  Existing solutions I found required buffering the multipart uploads into the actual filesystem which is difficult to scale.\n\n## Installation\n\n```sh\nnpm install --save multer-s3\n```\n\n## Usage\n\n```javascript\nvar aws = require('aws-sdk')\nvar express = require('express')\nvar multer = require('multer')\nvar multerS3 = require('multer-s3')\n\nvar app = express()\nvar s3 = new aws.S3({ /* ... */ })\n\nvar upload = multer({\n  storage: multerS3({\n    s3: s3,\n    bucket: 'some-bucket',\n    metadata: function (req, file, cb) {\n      cb(null, {fieldName: file.fieldname});\n    },\n    key: function (req, file, cb) {\n      cb(null, Date.now().toString())\n    }\n  })\n})\n\napp.post('/upload', upload.array('photos', 3), function(req, res, next) {\n  res.send('Successfully uploaded ' + req.files.length + ' files!')\n})\n```\n\n### File information\n\nEach file contains the following information exposed by `multer-s3`:\n\nKey | Description | Note\n--- | --- | ---\n`size` | Size of the file in bytes |\n`bucket` | The bucket used to store the file | `S3Storage`\n`key` | The name of the file | `S3Storage`\n`acl` | Access control for the file | `S3Storage`\n`contentType` | The `mimetype` used to upload the file | `S3Storage`\n`metadata` | The `metadata` object to be sent to S3 | `S3Storage`\n`location` | The S3 `url` to access the file  | `S3Storage`\n`etag` | The `etag`of the uploaded file in S3  | `S3Storage`\n`contentDisposition` | The `contentDisposition` used to upload the file | `S3Storage`\n`storageClass` | The `storageClass` to be used for the uploaded file in S3 | `S3Storage`\n`versionId` | The `versionId` is an optional param returned by S3 for versioned buckets. | `S3Storage`\n\n### Setting ACL\n\n[ACL values](http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) can be set by passing an optional `acl` parameter into the `multerS3` object.\n\n```javascript\nvar upload = multer({\n  storage: multerS3({\n    s3: s3,\n    bucket: 'some-bucket',\n    acl: 'public-read',\n    key: function (req, file, cb) {\n      cb(null, Date.now().toString())\n    }\n  })\n})\n```\n\nAvailable options for canned ACL.\n\nACL Option | Permissions added to ACL\n--- | ---\n`private` | Owner gets `FULL_CONTROL`. No one else has access rights (default).\n`public-read` | Owner gets `FULL_CONTROL`. The `AllUsers` group gets `READ` access.\n`public-read-write` | Owner gets `FULL_CONTROL`. The `AllUsers` group gets `READ` and `WRITE` access. Granting this on a bucket is generally not recommended.\n`aws-exec-read` | Owner gets `FULL_CONTROL`. Amazon EC2 gets `READ` access to `GET` an Amazon Machine Image (AMI) bundle from Amazon S3.\n`authenticated-read` | Owner gets `FULL_CONTROL`. The `AuthenticatedUsers` group gets `READ` access.\n`bucket-owner-read` | Object owner gets `FULL_CONTROL`. Bucket owner gets `READ` access. If you specify this canned ACL when creating a bucket, Amazon S3 ignores it.\n`bucket-owner-full-control` | Both the object owner and the bucket owner get `FULL_CONTROL` over the object. If you specify this canned ACL when creating a bucket, Amazon S3 ignores it.\n`log-delivery-write` | The `LogDelivery` group gets `WRITE` and `READ_ACP` permissions on the bucket. For more information on logs.\n\n## Setting Metadata\n\nThe `metadata` option is a callback that accepts the request and file, and returns a metadata object to be saved to S3.\n\nHere is an example that stores all fields in the request body as metadata, and uses an `id` param as the key: \n\n```javascript\nvar opts = {\n    s3: s3,\n    bucket: config.originalsBucket,\n    metadata: function (req, file, cb) {\n      cb(null, Object.assign({}, req.body));\n    },\n    key: function (req, file, cb) {\n      cb(null, req.params.id + \".jpg\");\n    }\n  };\n```\n\n## Setting Cache-Control header\n\nThe optional `cacheControl` option sets the `Cache-Control` HTTP header that will be sent if you're serving the files directly from S3. You can pass either a string or a function that returns a string.\n\nHere is an example that will tell browsers and CDNs to cache the file for one year:\n\n```javascript\nvar upload = multer({\n  storage: multerS3({\n    s3: s3,\n    bucket: 'some-bucket',\n    cacheControl: 'max-age=31536000',\n    key: function (req, file, cb) {\n      cb(null, Date.now().toString())\n    }\n  })\n})\n```\n\n## Setting Custom Content-Type\n\nThe optional `contentType` option can be used to set Content/mime type of the file. By default the content type is set to `application/octet-stream`. If you want multer-s3 to automatically find the content-type of the file, use the `multerS3.AUTO_CONTENT_TYPE` constant. Here is an example that will detect the content type of the file being uploaded.\n\n```javascript\nvar upload = multer({\n  storage: multerS3({\n    s3: s3,\n    bucket: 'some-bucket',\n    contentType: multerS3.AUTO_CONTENT_TYPE,\n    key: function (req, file, cb) {\n      cb(null, Date.now().toString())\n    }\n  })\n})\n```\nYou may also use a function as the `contentType`, which should be of the form `function(req, file, cb)`.\n\n## Setting StorageClass\n\n[storageClass values](https://aws.amazon.com/s3/storage-classes/) can be set by passing an optional `storageClass` parameter into the `multerS3` object.\n\n```javascript\nvar upload = multer({\n  storage: multerS3({\n    s3: s3,\n    bucket: 'some-bucket',\n    acl: 'public-read',\n    storageClass: 'REDUCED_REDUNDANCY',\n    key: function (req, file, cb) {\n      cb(null, Date.now().toString())\n    }\n  })\n})\n```\n\n## Setting Content-Disposition\n\nThe optional `contentDisposition` option can be used to set the `Content-Disposition` header for the uploaded file. By default, the `contentDisposition` isn't forwarded. As an example below, using the value `attachment` forces the browser to download the uploaded file instead of trying to open it.\n\n```javascript\nvar upload = multer({\n  storage: multerS3({\n    s3: s3,\n    bucket: 'some-bucket',\n    acl: 'public-read',\n    contentDisposition: 'attachment',\n    key: function (req, file, cb) {\n      cb(null, Date.now().toString())\n    }\n  })\n})\n```\n\n## Using Server-Side Encryption\n\n*An overview of S3's server-side encryption can be found in the [S3 Docs] (http://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html); be advised that customer-managed keys (SSE-C) is not implemented at this time.*\n\nYou may use the S3 server-side encryption functionality via the optional `serverSideEncryption` and `sseKmsKeyId` parameters. Full documentation of these parameters in relation to the S3 API can be found [here] (http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#upload-property) and [here] (http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html). \n\n`serverSideEncryption` has two valid values: 'AES256' and 'aws:kms'. 'AES256' utilizes the S3-managed key system, while 'aws:kms' utilizes the AWS KMS system and accepts the optional `sseKmsKeyId` parameter to specify the key ID of the key you wish to use. Leaving `sseKmsKeyId` blank when 'aws:kms' is specified will use the default KMS key. **Note:** *You must instantiate the S3 instance with `signatureVersion: 'v4'` in order to use KMS-managed keys [[Docs]] (http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingAWSSDK.html#specify-signature-version), and the specified key must be in the same AWS region as the S3 bucket used.*\n\n```javascript\nvar upload = multer({\n  storage: multerS3({\n    s3: s3,\n    bucket: 'some-bucket',\n    acl: 'authenticated-read',\n    contentDisposition: 'attachment',\n    serverSideEncryption: 'AES256',\n    key: function(req, file, cb) {\n      cb(null, Date.now().toString())\n    }\n  })\n})\n```\n\n## Testing\n\nThe tests mock all access to S3 and can be run completely offline.\n\n```sh\nnpm test\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/badunk/multer-s3.git"
  },
  "scripts": {
    "test": "standard && mocha test/basic.js"
  },
  "version": "2.9.0"
}
